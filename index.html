<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gargantua: Ultimate Physic Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: "Menlo", "Consolas", monospace;
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            z-index: 1;
        }

        /* HUD ÁïåÈù¢Â±Ç */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* È°∂ÈÉ®‰ª™Ë°®Áõò */
        .hud-panel {
            background: rgba(0, 10, 20, 0.6);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-left: 4px solid rgba(0, 150, 255, 0.8);
            padding: 15px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: rgba(200, 230, 255, 0.9);
            max-width: 350px;
            pointer-events: auto;
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0, 150, 255, 0.5);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 10px 0;
            color: #fff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 2px;
        }
        .data-label { color: rgba(100, 200, 255, 0.7); }
        .data-value { color: #fff; font-weight: bold; }
        
        .status-normal { color: #44ffaa; }
        .status-warning { color: #ffaa00; animation: pulse 2s infinite; }
        .status-danger { color: #ff3333; animation: flash 0.5s infinite; }

        @keyframes pulse { 0% {opacity:1;} 50% {opacity:0.7;} 100% {opacity:1;} }
        @keyframes flash { 0% {opacity:1;} 50% {opacity:0.3;} 100% {opacity:1;} }

        /* Â∫ïÈÉ®ÊéßÂà∂Ê†è */
        .controls-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .slider-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 250px;
            backdrop-filter: blur(5px);
        }

        .slider-label {
            font-size: 0.75rem;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        input[type=range] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            background: #0096ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 18px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-family: inherit;
        }
        .btn:hover { background: rgba(0, 150, 255, 0.3); border-color: rgba(0,150,255,0.8); }
        .btn:active { transform: scale(0.95); }
        .btn.active { background: rgba(0, 150, 255, 0.5); border-color: #0096ff; }
        .btn-danger { border-color: rgba(255, 50, 50, 0.5); color: #ffaaaa; }
        .btn-danger:hover { background: rgba(255, 50, 50, 0.3); }

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-layer">
        <!-- Â∑¶‰∏äËßíÔºöÊï∞ÊçÆÈÅ•Êµã -->
        <div class="hud-panel">
            <h1>TELEMETRY DATA</h1>
            <div class="data-row">
                <span class="data-label">Ë∑ùÁ¶ª (DISTANCE):</span>
                <span class="data-value" id="disp-dist">--</span>
            </div>
            <div class="data-row">
                <span class="data-label">Âå∫Âüü (ZONE):</span>
                <span class="data-value status-normal" id="disp-zone">INTERSTELLAR</span>
            </div>
            <div style="margin: 10px 0; border-top: 1px dashed rgba(255,255,255,0.2);"></div>
            <div class="data-row">
                <span class="data-label">‰∫ã‰ª∂ËßÜÁïå (Rh):</span>
                <span class="data-value" id="val-rh">2.00 M</span>
            </div>
            <div class="data-row">
                <span class="data-label">ÊúÄÂÜÖÁ®≥ÂÆöËΩ®ÈÅì (ISCO):</span>
                <span class="data-value" id="val-isco">6.00 M</span>
            </div>
            <div class="data-row">
                <span class="data-label">ÂÖâÂ≠êÁêÉ (Photon):</span>
                <span class="data-value" id="val-ph">3.00 M</span>
            </div>
        </div>

        <!-- Â∫ïÈÉ®ÔºöÊéßÂà∂ -->
        <div class="controls-container">
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>MASS (Ë¥®Èáè)</span>
                    <span id="lbl-mass">4.2</span>
                </div>
                <input type="range" id="inp-mass" min="1.0" max="10.0" step="0.1" value="4.2">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>SPIN (Ëá™Êóã a/M)</span>
                    <span id="lbl-spin">0.00</span>
                </div>
                <input type="range" id="inp-spin" min="0.0" max="0.99" step="0.01" value="0.0">
            </div>

            <div class="btn-group">
                <button class="btn" id="btn-star" onclick="toggleStar()">‰º¥Êòü: OFF</button>
                <button class="btn" id="btn-mode" onclick="toggleMode()">REALISM</button>
                <button class="btn btn-danger" onclick="jumpToHorizon()">üöÄ Á©øÊ¢≠ËßÜÁïå</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;

        uniform float iTime;
        uniform vec2 iResolution;
        uniform vec3 iCameraPos;
        uniform vec3 iCameraDir;
        uniform vec3 iCameraUp;
        uniform vec3 iCameraRight;
        uniform float iFOV;

        uniform float uMass;      
        uniform float uSpin;      
        uniform float uShowStar;
        uniform float uMode;      

        varying vec2 vUv;

        #define MAX_STEPS 200
        #define MAX_DIST 500.0
        #define PI 3.14159265359

        // --- Âô™Â£∞ÂáΩÊï∞ ---
        float hash(float n) { return fract(sin(n) * 43758.5453123); }
        float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            float n = p.x + p.y * 57.0 + p.z * 113.0;
            return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                        mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
        }
        float fbm(vec3 p) {
            float f = 0.0; float w = 0.5;
            for (int i = 0; i < 5; i++) { f += w * noise(p); p *= 2.02; w *= 0.5; }
            return f;
        }

        // --- ËÉåÊôØÁîüÊàê (Model 2 È£éÊ†º - Ê∑±ÈÇÉÁâà) ---
        vec3 getBackground(vec3 rd) {
            vec3 col = vec3(0.0);
            
            if (uMode > 0.5) {
                // Cinematic: Ê∑±ÈÇÉÂÆáÂÆô
                col = vec3(0.005, 0.005, 0.02); // ÊöóÂ∫ïËâ≤
                float nebula = fbm(rd * 1.5 + vec3(1.0));

                // ÈªëËâ≤Ê∑∑ÂÖ•Á¥´Ëâ≤ÔºåÂØπÊØîÂ∫¶Êõ¥È´ò
                vec3 nebulaCol = mix(vec3(0.0), vec3(0.1, 0.0, 0.2), smoothstep(0.4, 0.8, nebula));
                col += nebulaCol * 2.0;
                
                // ÈîêÂà©‰∏îÊòé‰∫ÆÁöÑÊòüÊòü
                float stars = pow(clamp(noise(rd * 150.0), 0.0, 1.0), 100.0) * 100.0;
                col += vec3(stars);
            } else {
                // Realism
                float n = noise(rd * 300.0);
                col += vec3(pow(max(0.0, n - 0.98) / 0.02, 12.0));
            }
            return col;
        }

        // --- ACES Tone Mapping ---
        vec3 ACESFilm(vec3 x) {
            float a = 2.51; float b = 0.03; float c = 2.43; float d = 0.59; float e = 0.14;
            return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
        }

        void main() {
            vec2 uv = vUv * 2.0 - 1.0;
            vec2 screenUV = vUv;
            uv.x *= iResolution.x / iResolution.y;

            vec3 rayDir = normalize(iCameraDir + uv.x * iCameraRight * iFOV + uv.y * iCameraUp * iFOV);
            vec3 pos = iCameraPos;

            // Áâ©ÁêÜÂèÇÊï∞
            float rInner = mix(6.0 * uMass, 1.2 * uMass, uSpin); 
            float rOuter = 15.0 * uMass;

            vec3 col = vec3(0.0);
            float glow = 0.0;
            float lensingArc = 0.0;
            
            vec3 starPos = vec3(15.0, 2.0 * uMass, -10.0);
            float starRadius = 1.5 * (uMass/4.0);

            // --- Raymarching ---
            
            bool hitSingularity = false;
            float stepSize = 0.1;
            float transmittance = 1.0; // <--- Êñ∞Â¢ûÔºöÂàùÂßãÈÄèÂ∞ÑÁéá‰∏∫ 1.0

            for(int i = 0; i < MAX_STEPS; i++) {
                float r = length(pos);
                
                // --- 1. Kerr-Schild Á©∫Èó¥ÊµÅÈÄüËøë‰ºº (Hardcore Physics) ---
                // ËÆ°ÁÆóÊóãËΩ¨ÈªëÊ¥ûÁöÑÂá†‰ΩïÂèÇÊï∞
                float a = uSpin * uMass;
                // rho2 ÊòØ Kerr Metric ‰∏≠ÁöÑÂÖ≥ÈîÆÂá†‰ΩïÈ°π
                float rho2 = r*r + a*a * (pos.y*pos.y)/(r*r + 0.001); 

                // ÂæÑÂêëÊµÅÈÄü (ÂêëÂÜÖ‰∏ãËêΩ)
                vec3 flowRadial = -normalize(pos) * sqrt(2.0 * uMass * r / (r*r + a*a));

                // ÂàáÂêëÊµÅÈÄü (ÂèÇËÄÉÁ≥ªÊãñÊõ≥) - Ëµ§ÈÅìÂ§ÑÊúÄÂº∫ÔºåÈöèË∑ùÁ¶ªË°∞Âáè
                vec3 up = vec3(0,1,0);
                vec3 flowTwist = normalize(cross(up, pos)) * (2.0 * uMass * a / (r*r*r + 0.1));

                // ÊúÄÁªàÁ©∫Èó¥ÈÄüÂ∫¶
                vec3 spaceVel = flowRadial + flowTwist;

                // --- 2. ÂÖâÁ∫ø‰∏éÁ©∫Èó¥‰∫§‰∫í ---
                vec3 totalVel = rayDir + spaceVel;
                stepSize = max(0.05, r * 0.05);
                
                // Â¶ÇÊûúÂú®ËßÜÁïåÂÜÖÔºåÂÖÅËÆ∏ÂÖâÁ∫øÁªßÁª≠ÊºîÂåñ (GPÂùêÊ†áÁâπÊÄß)
                pos += totalVel * stepSize;

                // --- 3. ÂÖâÁ∫øÊñπÂêëÂºØÊõ≤ (Geodesic Deviation + Twist) ---
                // ÂºïÂÖ• twist ‰ª•Â¢ûÂº∫ËßÜËßâ‰∏äÁöÑ‚ÄúÂç∑Êõ≤ÊÑü‚Äù
                vec3 toCenter = -normalize(pos);
                float r2 = r*r + 0.01;
                float bendStrength = (uMass) / r2; 
                vec3 twistVisual = vec3(-pos.z, 0.0, pos.x) * (uSpin * 0.5 / r2);
                
                rayDir = normalize(rayDir + (toCenter * bendStrength + twistVisual) * stepSize * 2.0);

                // --- Á¢∞ÊíûÊ£ÄÊµã ---
                if (r < 0.1) {
                    hitSingularity = true;
                    col = vec3(0.0);
                    break;
                }

                // --- ‰º¥ÊòüÊ∏≤Êüì ---
                if (uShowStar > 0.5) {
                    float dStar = length(pos - starPos) - starRadius;
                    if (dStar < 0.0) {
                        col += vec3(0.4, 0.7, 1.0) * 8.0 * transmittance; 
                        hitSingularity = true; 
                        break;
                    }
                    col += vec3(0.1, 0.3, 0.8) * (0.1 / (dStar*dStar + 0.1)) * stepSize * transmittance;
                }

                // --- Âê∏ÁßØÁõòÊ∏≤Êüì (Áâ©ÁêÜÂ¢ûÂº∫ÁâàÔºöÈÄèÂ∞ÑÁéá + Èªë‰ΩìËæêÂ∞Ñ) ---
                float diskThickness = 0.45 * uMass;
                float distToPlane = abs(pos.y);
                
                // Âè™ÊúâÂΩìÂÖâÁ∫øÊ≤°ÊúâË¢´ÂÆåÂÖ®ÈòªÊå°Êó∂ÊâçËÆ°ÁÆóÂê∏ÁßØÁõò
                if (transmittance > 0.01 && distToPlane < diskThickness && r > rInner && r < rOuter) {
                    
                    // 1. ÂØÜÂ∫¶Ë°∞Âáè (Fade)
                    float radialFade = smoothstep(rInner, rInner + 1.5, r) * smoothstep(rOuter, rOuter - 4.0, r);
                    float verticalFade = smoothstep(diskThickness, 0.0, distToPlane);
                    
                    // 2. ÂΩ¢Áä∂Êâ∞Âä® (Noise)
                    float angle = atan(pos.z, pos.x);
                    float orbitalSpeed = sqrt(uMass / r) + (uSpin / r);
                    float rotOffset = iTime * orbitalSpeed * 4.0;
                    
                    vec3 noiseP = vec3(angle * 4.0 + rotOffset, r * 0.5, pos.y * 3.0);
                    float density = fbm(noiseP);
                    
                    // ÊúÄÁªàÂº∫Â∫¶
                    float intensity = density * verticalFade * radialFade;

                    if (intensity > 0.05) {
                        // --- Áâ©ÁêÜÈ¢úËâ≤ÔºöÊ∏©Â∫¶Ê¢ØÂ∫¶ (Temperature Gradient) ---
                        float t = clamp((r - rInner) / (rOuter - rInner), 0.0, 1.0);
                        
                        vec3 cInner = vec3(1.5, 1.3, 1.0); // ÊûÅ‰∫ÆÁôΩÂÅèÈªÑ
                        vec3 cMid   = vec3(1.0, 0.5, 0.1); // Ê©ôËâ≤
                        vec3 cOuter = vec3(0.5, 0.05, 0.02); // Ê∑±Á∫¢
                        
                        vec3 diskCol = mix(cInner, cMid, smoothstep(0.0, 0.3, t));
                        diskCol = mix(diskCol, cOuter, smoothstep(0.3, 1.0, t));
                        
                        // --- Â§öÊôÆÂãíÊïàÂ∫î ---
                        vec3 diskVel = normalize(vec3(-pos.z, 0.0, pos.x));
                        float beamFactor = dot(rayDir, diskVel);
                        
                        // ‰∫ÆÂ∫¶Â¢ûÂº∫
                        float dopplerBright = pow(0.5 + 0.5 * (1.0 - beamFactor), 3.0);
                        // È¢ëÁßªÈ¢úËâ≤
                        vec3 shiftColor = mix(vec3(1.0, 0.8, 0.6), vec3(0.7, 0.9, 1.2), beamFactor * 0.5 + 0.5);
                        
                        diskCol *= dopplerBright * shiftColor;
                        
                        // --- Áâ©ÁêÜÂÖâÁÖßÂêàÊàê (Beer's Law) ---
                        float alpha = intensity * 0.25 * stepSize;
                        
                        // Á¥ØÂä†È¢úËâ≤
                        col += diskCol * transmittance * alpha * 4.0;
                        glow += intensity * transmittance * stepSize * 0.5;
                        lensingArc += intensity * transmittance * smoothstep(0.0, -diskThickness, pos.y);
                        
                        // Êõ¥Êñ∞ÈÄèÂ∞ÑÁéá
                        transmittance *= (1.0 - alpha);
                        
                        if (transmittance < 0.01) break; 
                    }
                }
                
                if (r > MAX_DIST) break;
            }

            // ËÉåÊôØÂêàÊàê (‰øÆÊ≠£‰∏∫ÈÄèÂ∞ÑÁéáÈÄªËæë)
            if (!hitSingularity) {
                vec3 bg = getBackground(rayDir);
                
                // Á∫¢ÁßªÈÄªËæë
                float rs = 2.0 * uMass;
                float rCam = length(iCameraPos);
                float redshift = 1.0;
                if (rCam < rs * 3.0) {
                     redshift = clamp(rCam / (rs * 2.0), 0.0, 1.0);
                }
                
                // Âè™ÊúâÊ≤°Ë¢´Âê∏ÁßØÁõòÊå°‰ΩèÁöÑÂÖâÁ∫ø(transmittance)ÊâçËÉΩÊòæÁ§∫ËÉåÊôØ
                col += bg * transmittance * redshift;
            }

            col += vec3(1.15, 0.85, 0.55) * lensingArc * smoothstep(0.4, 1.0, screenUV.y) * 0.5;

            col = ACESFilm(col);
            col = pow(col, vec3(1.0/2.2));
            
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const container = document.getElementById('canvas-container');
        const pixelRatio = window.devicePixelRatio;

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(pixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 100); 

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.minDistance = 0.1;
        controls.maxDistance = 500;
        controls.rotateSpeed = 0.3;
        controls.zoomSpeed = 1.2;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio) },
                iCameraPos: { value: new THREE.Vector3() },
                iCameraDir: { value: new THREE.Vector3() },
                iCameraUp: { value: new THREE.Vector3() },
                iCameraRight: { value: new THREE.Vector3() },
                iFOV: { value: 1.0 },
                
                uMass: { value: 4.2 },
                uSpin: { value: 0.0 },
                uShowStar: { value: 0.0 },
                uMode: { value: 0.0 }
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.frustumCulled = false;
        scene.add(mesh);

        // --- Áâ©ÁêÜËÆ°ÁÆóÈÄªËæë ---

        const UI = {
            dist: document.getElementById('disp-dist'),
            zone: document.getElementById('disp-zone'),
            rh: document.getElementById('val-rh'),
            isco: document.getElementById('val-isco'),
            ph: document.getElementById('val-ph'),
            massInput: document.getElementById('inp-mass'),
            massLabel: document.getElementById('lbl-mass'),
            spinInput: document.getElementById('inp-spin'),
            spinLabel: document.getElementById('lbl-spin'),
        };

        function calcBlackHoleProperties(M, a_star) {
            const a = a_star * M;
            const rh = M + Math.sqrt(M*M - a*a);
            
            const Z1 = 1 + Math.pow(1 - a_star*a_star, 1.0/3.0) * (Math.pow(1 + a_star, 1.0/3.0) + Math.pow(1 - a_star, 1.0/3.0));
            const Z2 = Math.sqrt(3 * a_star * a_star + Z1 * Z1);
            const iscoFactor = 3 + Z2 - Math.sqrt((3 - Z1) * (3 + Z1 + 2 * Z2));
            const isco = M * iscoFactor;
            const ph = 2 * M * (1 + Math.cos(2.0/3.0 * Math.acos(-a_star)));

            return { rh, isco, ph };
        }

        function updateHUD(dist, M, props) {
            UI.dist.innerText = dist.toFixed(2) + " M";
            
            let zoneText = "INTERSTELLAR (ÊòüÈôÖÁ©∫Èó¥)";
            let statusClass = "status-normal";
            const ergosphereRad = 2.0 * M; 

            if (dist < props.rh) {
                zoneText = "‚ö†Ô∏è INSIDE HORIZON (ËßÜÁïåÂÜÖ)";
                statusClass = "status-danger";
            } else if (dist < props.ph) {
                zoneText = "‚ö†Ô∏è PHOTON SPHERE (ÂÖâÂ≠êÁêÉ)";
                statusClass = "status-danger";
            } else if (dist < props.isco) {
                zoneText = "‚ö†Ô∏è ACCRETION DISK (Âê∏ÁßØÁõò)";
                statusClass = "status-warning";
            } else if (dist < ergosphereRad) {
                zoneText = "ERGOSPHERE (ËÉΩÂ±Ç)";
                statusClass = "status-warning";
            }

            UI.zone.innerText = zoneText;
            UI.zone.className = "data-value " + statusClass;
            UI.rh.innerText = props.rh.toFixed(2) + " u";
            UI.isco.innerText = props.isco.toFixed(2) + " u";
            UI.ph.innerText = props.ph.toFixed(2) + " u";
        }

        // --- ‰∫§‰∫í‰∫ã‰ª∂ ---

        UI.massInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            material.uniforms.uMass.value = val;
            UI.massLabel.innerText = val.toFixed(1);
        });

        UI.spinInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            material.uniforms.uSpin.value = val;
            UI.spinLabel.innerText = val.toFixed(2);
        });

        window.toggleStar = function() {
            const btn = document.getElementById('btn-star');
            const current = material.uniforms.uShowStar.value;
            if (current > 0.5) {
                material.uniforms.uShowStar.value = 0.0;
                btn.innerText = "‰º¥Êòü: OFF";
                btn.classList.remove('active');
            } else {
                material.uniforms.uShowStar.value = 1.0;
                btn.innerText = "‰º¥Êòü: ON";
                btn.classList.add('active');
            }
        };

        window.toggleMode = function() {
            const btn = document.getElementById('btn-mode');
            const current = material.uniforms.uMode.value;
            if (current > 0.5) {
                material.uniforms.uMode.value = 0.0;
                btn.innerText = "È£éÊ†º: REALISM";
                btn.classList.remove('active');
            } else {
                material.uniforms.uMode.value = 1.0;
                btn.innerText = "È£éÊ†º: CINEMA";
                btn.classList.add('active');
            }
        };

        window.jumpToHorizon = function() {
            const M = material.uniforms.uMass.value;
            const spin = material.uniforms.uSpin.value;
            const props = calcBlackHoleProperties(M, spin);
            const outward = camera.position.clone();
            if (outward.lengthSq() < 1e-4) outward.set(1, 0, 0);
            outward.normalize();
            const horizonRadius = props.rh * 1.02;
            const horizonPos = outward.clone().multiplyScalar(horizonRadius);
            camera.position.copy(horizonPos);
            const lookTarget = horizonPos.clone().add(outward.clone().multiplyScalar(M * 5.0));
            controls.target.copy(lookTarget);
            controls.update();
        };

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.iResolution.value.set(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
        }

        // --- Âä®ÁîªÂæ™ÁéØ ---

        const clock = new THREE.Clock();
        const vecForward = new THREE.Vector3();
        const vecUp = new THREE.Vector3();
        const vecRight = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            material.uniforms.iTime.value = time;
            material.uniforms.iCameraPos.value.copy(camera.position);

            camera.getWorldDirection(vecForward);
            vecUp.copy(camera.up).applyQuaternion(camera.quaternion);
            vecRight.crossVectors(vecForward, vecUp).normalize();
            vecUp.crossVectors(vecRight, vecForward).normalize();

            material.uniforms.iCameraDir.value.copy(vecForward);
            material.uniforms.iCameraUp.value.copy(vecUp);
            material.uniforms.iCameraRight.value.copy(vecRight);
            material.uniforms.iFOV.value = Math.tan((camera.fov * Math.PI / 180) * 0.5);

            const currentDist = camera.position.length();
            const M = material.uniforms.uMass.value;
            const spin = material.uniforms.uSpin.value;
            const props = calcBlackHoleProperties(M, spin);
            
            updateHUD(currentDist, M, props);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
