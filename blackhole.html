<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Gargantua: GP Metric Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: "Menlo", "Consolas", monospace; /* ä½¿ç”¨ç­‰å®½å­—ä½“å¢å¼ºç§‘å¹»æ„Ÿ */
            touch-action: none;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            z-index: 1;
        }

        /* HUD ç•Œé¢å±‚ */
        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
            padding: 20px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* é¡¶éƒ¨ä»ªè¡¨ç›˜ */
        .hud-panel {
            background: rgba(0, 10, 20, 0.6);
            border: 1px solid rgba(0, 150, 255, 0.3);
            border-left: 4px solid rgba(0, 150, 255, 0.8);
            padding: 15px;
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            color: rgba(200, 230, 255, 0.9);
            max-width: 350px;
            pointer-events: auto;
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0, 150, 255, 0.5);
        }

        h1 {
            font-size: 1.2rem;
            margin: 0 0 10px 0;
            color: #fff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            margin-bottom: 5px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            padding-bottom: 2px;
        }
        .data-label { color: rgba(100, 200, 255, 0.7); }
        .data-value { color: #fff; font-weight: bold; }
        
        /* è­¦å‘ŠçŠ¶æ€æ ·å¼ */
        .status-normal { color: #44ffaa; }
        .status-warning { color: #ffaa00; animation: pulse 2s infinite; }
        .status-danger { color: #ff3333; animation: flash 0.5s infinite; }

        @keyframes pulse { 0% {opacity:1;} 50% {opacity:0.7;} 100% {opacity:1;} }
        @keyframes flash { 0% {opacity:1;} 50% {opacity:0.3;} 100% {opacity:1;} }

        /* åº•éƒ¨æ§åˆ¶æ  */
        .controls-container {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: flex-end;
        }

        .slider-group {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 250px;
            backdrop-filter: blur(5px);
        }

        .slider-label {
            font-size: 0.75rem;
            color: #aaa;
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }

        input[type=range] {
            width: 100%;
            appearance: none;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            height: 4px;
            border-radius: 2px;
            outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px; height: 16px;
            background: #0096ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 18px;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            font-family: inherit;
        }
        .btn:hover { background: rgba(0, 150, 255, 0.3); border-color: rgba(0,150,255,0.8); }
        .btn:active { transform: scale(0.95); }
        .btn.active { background: rgba(0, 150, 255, 0.5); border-color: #0096ff; }
        .btn-danger { border-color: rgba(255, 50, 50, 0.5); color: #ffaaaa; }
        .btn-danger:hover { background: rgba(255, 50, 50, 0.3); }

    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- ä½¿ç”¨ PointerLockControls ä»¥ä¾¿è·å¾—ç±»ä¼¼é£è¡Œçš„ä½“éªŒï¼Œæˆ–è€…ç»§ç»­ä½¿ç”¨ OrbitControls ä½†å…è®¸ç©¿é€ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="ui-layer">
        <!-- å·¦ä¸Šè§’ï¼šæ•°æ®é¥æµ‹ -->
        <div class="hud-panel">
            <h1>TELEMETRY DATA</h1>
            <div class="data-row">
                <span class="data-label">è·ç¦» (DISTANCE):</span>
                <span class="data-value" id="disp-dist">--</span>
            </div>
            <div class="data-row">
                <span class="data-label">åŒºåŸŸ (ZONE):</span>
                <span class="data-value status-normal" id="disp-zone">INTERSTELLAR</span>
            </div>
            <div style="margin: 10px 0; border-top: 1px dashed rgba(255,255,255,0.2);"></div>
            <div class="data-row">
                <span class="data-label">äº‹ä»¶è§†ç•Œ (Rh):</span>
                <span class="data-value" id="val-rh">2.00 M</span>
            </div>
            <div class="data-row">
                <span class="data-label">æœ€å†…ç¨³å®šè½¨é“ (ISCO):</span>
                <span class="data-value" id="val-isco">6.00 M</span>
            </div>
            <div class="data-row">
                <span class="data-label">å…‰å­çƒ (Photon):</span>
                <span class="data-value" id="val-ph">3.00 M</span>
            </div>
        </div>

        <!-- åº•éƒ¨ï¼šæ§åˆ¶ -->
        <div class="controls-container">
            
            <div class="slider-group">
                <div class="slider-label">
                    <span>MASS (è´¨é‡)</span>
                    <span id="lbl-mass">4.2</span>
                </div>
                <input type="range" id="inp-mass" min="1.0" max="10.0" step="0.1" value="4.2">
            </div>

            <div class="slider-group">
                <div class="slider-label">
                    <span>SPIN (è‡ªæ—‹ a/M)</span>
                    <span id="lbl-spin">0.00</span>
                </div>
                <!-- Spin 0 åˆ° 0.99 (Kerré»‘æ´æé™) -->
                <input type="range" id="inp-spin" min="0.0" max="0.99" step="0.01" value="0.0">
            </div>

            <div class="btn-group">
                <button class="btn" id="btn-star" onclick="toggleStar()">ä¼´æ˜Ÿ: OFF</button>
                <button class="btn" id="btn-mode" onclick="toggleMode()">REALISM</button>
                <button class="btn btn-danger" onclick="jumpToHorizon()">ğŸš€ ç©¿æ¢­è§†ç•Œ</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script id="vertexShader" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = vec4(position.xy, 0.0, 1.0);
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        precision highp float;

        uniform float iTime;
        uniform vec2 iResolution;
        uniform vec3 iCameraPos;
        uniform vec3 iCameraDir;
        uniform vec3 iCameraUp;
        uniform vec3 iCameraRight;
        uniform float iFOV;

        // äº¤äº’å‚æ•°
        uniform float uMass;      // é»‘æ´è´¨é‡
        uniform float uSpin;      // è‡ªæ—‹ (0.0 ~ 1.0)
        uniform float uShowStar;
        uniform float uMode;      // 0.0 = Real, 1.0 = Cinema
        
        // é¢„è®¡ç®—çš„åŠå¾„ (ç”±JSä¼ å…¥æˆ–Shaderå†…è®¡ç®—ï¼Œè¿™é‡Œç®€åŒ–ä¸ºShaderå†…åŸºäºMassä¼°ç®—)
        // å®é™…ä¸Š ISCO å’Œ è§†ç•ŒåŠå¾„ä¼šéš Spin å˜åŒ–ï¼Œæˆ‘ä»¬åœ¨ JS é‡Œç®—å¥½å¸ç§¯ç›˜å¤§å°ä¼ è¿›æ¥æ›´å¥½ï¼Œ
        // ä½†ä¸ºäº†è‡ªæ´½ï¼Œæˆ‘ä»¬åœ¨ Shader é‡Œç”¨ç®€å•çš„ Kerr è¿‘ä¼¼ã€‚

        varying vec2 vUv;

        #define MAX_STEPS 200
        #define MAX_DIST 500.0
        #define PI 3.14159265359

        // --- å™ªå£°å‡½æ•° ---
        float hash(float n) { return fract(sin(n) * 43758.5453123); }
        float noise(vec3 x) {
            vec3 p = floor(x);
            vec3 f = fract(x);
            f = f * f * (3.0 - 2.0 * f);
            float n = p.x + p.y * 57.0 + p.z * 113.0;
            return mix(mix(mix(hash(n + 0.0), hash(n + 1.0), f.x),
                        mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y),
                    mix(mix(hash(n + 113.0), hash(n + 114.0), f.x),
                        mix(hash(n + 170.0), hash(n + 171.0), f.x), f.y), f.z);
        }
        float fbm(vec3 p) {
            float f = 0.0; float w = 0.5;
            for (int i = 0; i < 5; i++) { f += w * noise(p); p *= 2.02; w *= 0.5; }
            return f;
        }

        // --- èƒŒæ™¯ç”Ÿæˆ ---
        vec3 getBackground(vec3 rd) {
            vec3 col = vec3(0.0);
            
            if (uMode > 0.5) {
                // Cinematic: æ˜Ÿäº‘
                float nebula = fbm(rd * 1.8 + vec3(1.0));
                vec3 nebulaCol = mix(vec3(0.05, 0.0, 0.1), vec3(0.0, 0.1, 0.3), smoothstep(0.3, 0.7, nebula));
                col += nebulaCol * 1.5;
                float stars = pow(clamp(noise(rd * 200.0), 0.0, 1.0), 80.0) * 80.0;
                col += vec3(stars);
            } else {
                // Realism: åªæœ‰æ˜Ÿæ˜Ÿ
                float n = noise(rd * 350.0);
                if (n > 0.98) {
                    col += vec3(pow((n - 0.98) / 0.02, 6.0));
                }
            }
            return col;
        }

        // --- ACES Tone Mapping ---
        vec3 ACESFilm(vec3 x) {
            float a = 2.51; float b = 0.03; float c = 2.43; float d = 0.59; float e = 0.14;
            return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0.0, 1.0);
        }

        void main() {
            vec2 uv = vUv * 2.0 - 1.0;
            vec2 screenUV = vUv;
            uv.x *= iResolution.x / iResolution.y;

            // åˆå§‹å…‰çº¿æ–¹å‘
            vec3 rayDir = normalize(iCameraDir + uv.x * iCameraRight * iFOV + uv.y * iCameraUp * iFOV);
            vec3 pos = iCameraPos;

            // --- ç‰©ç†å‚æ•°è®¡ç®— ---
            // è§†ç•ŒåŠå¾„ Rh = M + sqrt(M^2 - a^2)ï¼Œè¿™é‡Œç®€åŒ– M=uMass
            float rh = uMass + sqrt(uMass*uMass - uSpin*uSpin*uMass*uMass);
            // ISCO è¿‘ä¼¼: éšç€ Spin å¢åŠ ï¼ŒISCO å‡å°ã€‚è¿™é‡Œåšä¸€ä¸ªçº¿æ€§æ’å€¼è¿‘ä¼¼ç”¨äºè§†è§‰
            float rInner = mix(6.0 * uMass, 1.2 * uMass, uSpin); 
            float rOuter = 15.0 * uMass;

            vec3 col = vec3(0.0);
            float glow = 0.0;
            float lensingArc = 0.0;
            
            // ä¼´æ˜Ÿä½ç½®
            vec3 starPos = vec3(15.0, 2.0 * uMass, -10.0);
            float starRadius = 1.5 * (uMass/4.0);

            // --- Raymarching: Gullstrand-PainlevÃ© (River Model) è¿‘ä¼¼ ---
            // åœ¨ GP åæ ‡ä¸­ï¼Œç©ºé—´ä»¥é€Ÿåº¦ v = -sqrt(2M/r) æµå‘å¥‡ç‚¹ã€‚
            // å…‰ç›¸å¯¹äºç©ºé—´çš„é€Ÿåº¦æ˜¯ c=1ã€‚
            // å› æ­¤å…‰åœ¨åæ ‡ç³»ä¸­çš„æ€»é€Ÿåº¦æ˜¯: v_light = rayDir + v_space
            
            bool hitSingularity = false;
            float stepSize = 0.1;

            for(int i = 0; i < MAX_STEPS; i++) {
                float r = length(pos);
                
                // 1. è®¡ç®—ç©ºé—´æµé€Ÿ (River Velocity)
                // v_space = -sqrt(2M/r) * r_hat
                // ä¸ºäº†é˜²æ­¢ r=0 é™¤é›¶ï¼ŒåŠ ä¸ªæå°å€¼
                float escapeVel = sqrt(2.0 * uMass / (r + 0.001));
                vec3 spaceVel = -normalize(pos) * escapeVel;

                // 2. è‡ªæ—‹äº§ç”Ÿçš„å‚è€ƒç³»æ‹–æ›³ (Frame Dragging) è¿‘ä¼¼
                // åªæœ‰åœ¨éå¸¸é è¿‘æ—¶æ‰æ˜¾è‘—ï¼Œè¡¨ç°ä¸ºæ¨ªå‘çš„ç©ºé—´æµåŠ¨
                if (uSpin > 0.01) {
                    vec3 up = vec3(0.0, 1.0, 0.0);
                    vec3 dragDir = normalize(cross(up, pos));
                    // æ‹–æ›³é€Ÿåº¦éš 1/r^3 è¡°å‡ (è¿‘ä¼¼)
                    float dragMag = (2.0 * uMass * uMass * uSpin) / (r*r + 0.1); 
                    spaceVel += dragDir * dragMag;
                }

                // 3. æ›´æ–°å…‰çº¿ä½ç½®
                // å…‰çš„æ€»é€Ÿåº¦ = è‡ªèº«çš„å•ä½å‘é‡ + ç©ºé—´æµé€Ÿ
                vec3 totalVel = rayDir + spaceVel;
                
                // åŠ¨æ€æ­¥é•¿ï¼šè¿œå¤„æ­¥é•¿é•¿ï¼Œè¿‘å¤„æ­¥é•¿çŸ­
                stepSize = max(0.05, r * 0.05);
                
                // å¦‚æœåœ¨è§†ç•Œå†…ï¼Œå…è®¸å…‰çº¿ç»§ç»­è¢«å¸å…¥
                // GPåæ ‡ç³»çš„ç‰¹ç‚¹ï¼šåœ¨è§†ç•Œå¤„ spaceVel = 1.0 (å…‰é€Ÿ)ï¼Œå¦‚æœ rayDir å‘å¤–ï¼Œåˆ™æ€»é€Ÿåº¦ä¸º0ï¼ˆå…‰åœæ»ï¼‰ï¼Œå¦‚æœå‘å†…åˆ™åŠ é€Ÿã€‚
                // æˆ‘ä»¬çš„æ¨¡æ‹Ÿä¼šè‡ªåŠ¨å¤„ç†è¿™ä¸ªï¼Œæ— éœ€ç‰¹æ®Š if åˆ¤æ–­ï¼Œä»è€Œå®ç°å¹³æ»‘ç©¿è¶Šã€‚
                
                pos += totalVel * stepSize;

                // 4. æ›´æ–°å…‰çº¿æ–¹å‘ (Ray Bending / Geodesic deviation)
                // åœ¨ River Model ä¸­ï¼Œå…‰çº¿æ–¹å‘å®é™…ä¸Šä¸éœ€è¦åƒç‰›é¡¿åŠ›å­¦é‚£æ ·å¼¯æ›²ï¼Œ
                // è€Œæ˜¯é€šè¿‡ "advection" è‡ªåŠ¨å¼¯æ›²ã€‚
                // ä½†æ˜¯ä¸ºäº†è§†è§‰æ•ˆæœæ›´é”åˆ©ï¼Œæˆ‘ä»¬ä¿®æ­£ rayDir ä»¥ä¿æŒå…¶ç›¸å¯¹äºç©ºé—´çš„å½’ä¸€åŒ–
                // (è¿™æ˜¯ç®€åŒ–çš„ Hamiltonian å…‰å­¦å¤„ç†)
                // ä¸€ä¸ªç®€å•çš„æŠ€å·§ï¼šæ ¹æ®ç©ºé—´é€Ÿåº¦æ¢¯åº¦çš„å½±å“ç¨å¾®æ—‹è½¬ rayDir (æ¨¡æ‹Ÿæµ‹åœ°çº¿)
                // ä½†åœ¨ WebGL ä¸­ï¼Œæœ€ç®€å•ä¸”æ•ˆæœæœ€å¥½çš„æ˜¯è®© pos éšæµè€ŒåŠ¨ï¼Œ
                // åŒæ—¶ rayDir ç¼“æ…¢å‘å¥‡ç‚¹å¼¯æ›²ä»¥æ¨¡æ‹Ÿæ—¶ç©ºæ›²ç‡:
                vec3 toCenter = -normalize(pos);
                float bendStrength = (uMass) / (r*r + 0.1); 
                rayDir = normalize(rayDir + toCenter * bendStrength * stepSize * 2.0);

                // --- ç¢°æ’æ£€æµ‹ ---
                
                // å¥‡ç‚¹ (Singularity)
                if (r < 0.1) {
                    hitSingularity = true;
                    col = vec3(0.0); // çº¯é»‘
                    break;
                }

                // --- ä¼´æ˜Ÿæ¸²æŸ“ ---
                if (uShowStar > 0.5) {
                    float dStar = length(pos - starPos) - starRadius;
                    if (dStar < 0.0) {
                        col += vec3(0.4, 0.7, 1.0) * 8.0; 
                        hitSingularity = true; // å€Ÿç”¨å˜é‡åœæ­¢
                        break;
                    }
                    col += vec3(0.1, 0.3, 0.8) * (0.1 / (dStar*dStar + 0.1)) * stepSize;
                }

                // --- å¸ç§¯ç›˜æ¸²æŸ“ (Volumetric) ---
                // å¸ç§¯ç›˜ä½äº y=0 å¹³é¢
                float diskThickness = 0.45 * uMass;
                float distToPlane = abs(pos.y);
                if (distToPlane < diskThickness && r > rInner && r < rOuter) {
                    float radialFade = smoothstep(rInner, rInner + 1.0, r) 
                                     * smoothstep(rOuter, rOuter - 4.0, r);
                    float baseNoise = fbm(pos * 0.4 + vec3(0.0, iTime * 0.12, 0.0));
                    float warpedY = pos.y + (baseNoise - 0.5) * diskThickness * 0.35;

                    for (int layer = 0; layer < 2; layer++) {
                        float layerOffset = (float(layer) - 0.5) * 0.25 * diskThickness;
                        float layerY = warpedY + layerOffset;
                        float layerDist = abs(layerY);
                        float layerFade = smoothstep(diskThickness, 0.0, layerDist) * radialFade;

                        if (layerFade > 0.001) {
                            float angle = atan(pos.z, pos.x);
                            float speed = 5.0 * sqrt(uMass) / pow(r, 1.5);
                            float rotOffset = iTime * speed + float(layer) * 0.8;
                            
                            vec3 noiseP = vec3(angle * 4.5 + rotOffset, r * 0.55 + float(layer) * 0.4, layerY * 1.8);
                            float density = fbm(noiseP);
                            
                            float intensity = density * layerFade * 2.4;

                            if (intensity > 0.005) {
                                vec3 cHot = vec3(1.2, 1.0, 0.8);
                                vec3 cWarm = vec3(1.0, 0.6, 0.2);
                                vec3 cCool = vec3(0.6, 0.3, 0.05);
                                float t = clamp((r - rInner) / (rOuter - rInner), 0.0, 1.0);
                                vec3 diskCol = mix(mix(cHot, cWarm, pow(t, 0.6)), cCool, t);
                                diskCol *= 0.8 + 0.2 * density;
                                
                                vec3 diskVel = normalize(vec3(-pos.z, 0.0, pos.x));
                                float doppler = pow(0.6 + 0.4 * (1.0 - dot(rayDir, diskVel)), 4.0);
                                vec3 raySide = normalize(vec3(rayDir.z, 0.0, -rayDir.x));
                                float blueShift = 0.5 + 0.5 * dot(diskVel, raySide);
                                vec3 dopplerTint = mix(vec3(1.2, 0.8, 0.6), vec3(0.5, 0.7, 1.2), blueShift);
                                diskCol *= dopplerTint;
                                
                                col += diskCol * intensity * doppler * stepSize * 0.6;
                                glow += intensity * stepSize * 0.12;
                                lensingArc += intensity * smoothstep(0.0, -diskThickness, layerY);
                            }
                        }
                    }
                }
                
                if (r > MAX_DIST) break;
            }

            // èƒŒæ™¯åˆæˆ
            if (!hitSingularity) {
                vec3 bg = getBackground(rayDir);
                // ç®€å•çš„å¼•åŠ›çº¢ç§»æ¨¡æ‹Ÿï¼šå…‰çº¿è¶Šé è¿‘é»‘æ´å‡ºæ¥ï¼Œè¶Šæš—/çº¢ (æ­¤å¤„ä»…åšäº®åº¦è¡°å‡)
                col += bg * max(0.0, 1.0 - glow);
            }

            col += vec3(1.15, 0.85, 0.55) * lensingArc * smoothstep(0.4, 1.0, screenUV.y);

            col = ACESFilm(col);
            col = pow(col, vec3(1.0/2.2));
            
            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const container = document.getElementById('canvas-container');
        const pixelRatio = window.devicePixelRatio; // å…¨é‡åƒç´ æ¯”ï¼Œæè‡´æ¸…æ™°

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(pixelRatio);
        container.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // åˆå§‹ä½ç½®è®¾ç½®å¾—ç¨å¾®è¿œä¸€ç‚¹ï¼Œæ–¹ä¾¿è§‚å¯Ÿ
        camera.position.set(0, 6, 100); 

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.minDistance = 0.1; // å…è®¸æå…¶æ¥è¿‘
        controls.maxDistance = 500;
        controls.rotateSpeed = 0.3;
        controls.zoomSpeed = 1.2;

        const geometry = new THREE.PlaneGeometry(2, 2);
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new THREE.Vector2(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio) },
                iCameraPos: { value: new THREE.Vector3() },
                iCameraDir: { value: new THREE.Vector3() },
                iCameraUp: { value: new THREE.Vector3() },
                iCameraRight: { value: new THREE.Vector3() },
                iFOV: { value: 1.0 },
                
                uMass: { value: 4.2 },
                uSpin: { value: 0.0 },
                uShowStar: { value: 0.0 },
                uMode: { value: 0.0 }
            }
        });

        const mesh = new THREE.Mesh(geometry, material);
        mesh.frustumCulled = false;
        scene.add(mesh);

        // --- ç‰©ç†è®¡ç®—é€»è¾‘ (Gargantua Logic) ---

        const UI = {
            dist: document.getElementById('disp-dist'),
            zone: document.getElementById('disp-zone'),
            rh: document.getElementById('val-rh'),
            isco: document.getElementById('val-isco'),
            ph: document.getElementById('val-ph'),
            massInput: document.getElementById('inp-mass'),
            massLabel: document.getElementById('lbl-mass'),
            spinInput: document.getElementById('inp-spin'),
            spinLabel: document.getElementById('lbl-spin'),
        };

        // è®¡ç®—Kerré»‘æ´çš„å…³é”®åŠå¾„
        function calcBlackHoleProperties(M, a_star) {
            // a_star = J / M^2 (0 ~ 1)
            // ç‰©ç†ä¸Šçš„ a = a_star * M
            // è§†ç•Œ Rh = M + sqrt(M^2 - a^2)
            const a = a_star * M;
            const rh = M + Math.sqrt(M*M - a*a);
            
            // ISCO (æœ€å†…ç¨³å®šåœ†è½¨é“)
            // Z1 = 1 + (1 - a*^2)^(1/3) * ((1 + a*)^(1/3) + (1 - a*)^(1/3))
            // Z2 = sqrt(3*a*^2 + Z1^2)
            // R_isco = M * (3 + Z2 - sqrt((3 - Z1)(3 + Z1 + 2*Z2)))
            // (è¿™æ˜¯é¡ºè¡Œè½¨é“å…¬å¼ï¼Œé€†è¡Œä¼šæ›´å¤§)
            const Z1 = 1 + Math.pow(1 - a_star*a_star, 1.0/3.0) * (Math.pow(1 + a_star, 1.0/3.0) + Math.pow(1 - a_star, 1.0/3.0));
            const Z2 = Math.sqrt(3 * a_star * a_star + Z1 * Z1);
            const iscoFactor = 3 + Z2 - Math.sqrt((3 - Z1) * (3 + Z1 + 2 * Z2));
            const isco = M * iscoFactor;

            // å…‰å­çƒ (Photon Sphere)
            // å²ç“¦è¥¿æ˜¯ 3Mï¼Œæå€¼å…‹å°”æ˜¯ M (é¡ºè¡Œ)ã€‚
            // è¿‘ä¼¼å…¬å¼: R_ph â‰ˆ 2M (1 + cos(2/3 * acos(-|a*|)))
            const ph = 2 * M * (1 + Math.cos(2.0/3.0 * Math.acos(-a_star)));

            return { rh, isco, ph };
        }

        function updateHUD(dist, M, props) {
            // è·ç¦»æ˜¾ç¤º
            UI.dist.innerText = dist.toFixed(2) + " M";
            
            // åŒºåŸŸåˆ¤å®š
            let zoneText = "INTERSTELLAR (æ˜Ÿé™…ç©ºé—´)";
            let statusClass = "status-normal";
            
            // èƒ½å±‚ (Ergosphere) åŠå¾„ Re = M + sqrt(M^2 - a^2 cos^2(theta))
            // ç®€åŒ–åˆ¤æ–­ï¼šèµ¤é“é¢ä¸Š Re = 2M
            const ergosphereRad = 2.0 * M; 

            if (dist < props.rh) {
                zoneText = "âš ï¸ INSIDE HORIZON (è§†ç•Œå†…)";
                statusClass = "status-danger";
            } else if (dist < props.ph) {
                zoneText = "âš ï¸ PHOTON SPHERE (å…‰å­çƒ)";
                statusClass = "status-danger";
            } else if (dist < props.isco) {
                zoneText = "âš ï¸ ACCRETION DISK (å¸ç§¯ç›˜)";
                statusClass = "status-warning";
            } else if (dist < ergosphereRad) {
                zoneText = "ERGOSPHERE (èƒ½å±‚)";
                statusClass = "status-warning";
            }

            UI.zone.innerText = zoneText;
            UI.zone.className = "data-value " + statusClass;

            // æ›´æ–°å‚è€ƒæ•°å€¼
            UI.rh.innerText = props.rh.toFixed(2) + " u";
            UI.isco.innerText = props.isco.toFixed(2) + " u";
            UI.ph.innerText = props.ph.toFixed(2) + " u";
        }

        // --- äº¤äº’äº‹ä»¶ ---

        UI.massInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            material.uniforms.uMass.value = val;
            UI.massLabel.innerText = val.toFixed(1);
        });

        UI.spinInput.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            material.uniforms.uSpin.value = val;
            UI.spinLabel.innerText = val.toFixed(2);
        });

        window.toggleStar = function() {
            const btn = document.getElementById('btn-star');
            const current = material.uniforms.uShowStar.value;
            if (current > 0.5) {
                material.uniforms.uShowStar.value = 0.0;
                btn.innerText = "ä¼´æ˜Ÿ: OFF";
                btn.classList.remove('active');
            } else {
                material.uniforms.uShowStar.value = 1.0;
                btn.innerText = "ä¼´æ˜Ÿ: ON";
                btn.classList.add('active');
            }
        };

        window.toggleMode = function() {
            const btn = document.getElementById('btn-mode');
            const current = material.uniforms.uMode.value;
            if (current > 0.5) {
                material.uniforms.uMode.value = 0.0;
                btn.innerText = "é£æ ¼: REALISM";
                btn.classList.remove('active');
            } else {
                material.uniforms.uMode.value = 1.0;
                btn.innerText = "é£æ ¼: CINEMA";
                btn.classList.add('active');
            }
        };

        window.jumpToHorizon = function() {
            const M = material.uniforms.uMass.value;
            const spin = material.uniforms.uSpin.value;
            const props = calcBlackHoleProperties(M, spin);

            // å–å½“å‰ç›¸æœºä½ç½®æ–¹å‘ä½œä¸ºå‡ºå°„æ–¹å‘ï¼Œè‹¥è¿‡è¿‘åˆ™é»˜è®¤æ²¿ X è½´
            const outward = camera.position.clone();
            if (outward.lengthSq() < 1e-4) outward.set(1, 0, 0);
            outward.normalize();

            // æ”¾ç½®åœ¨è§†ç•Œå¤–ä¸€å°æ®µè·ç¦»
            const horizonRadius = props.rh * 1.02;
            const horizonPos = outward.clone().multiplyScalar(horizonRadius);
            camera.position.copy(horizonPos);

            // é¢å‘å¤–å¤ªç©ºï¼ˆæ²¿åŠå¾„æ–¹å‘ï¼‰
            const lookTarget = horizonPos.clone().add(outward.clone().multiplyScalar(M * 5.0));
            controls.target.copy(lookTarget);
            controls.update();
        };

        window.addEventListener('resize', onWindowResize, false);
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.iResolution.value.set(window.innerWidth * pixelRatio, window.innerHeight * pixelRatio);
        }

        // --- åŠ¨ç”»å¾ªç¯ ---

        const clock = new THREE.Clock();
        const vecForward = new THREE.Vector3();
        const vecUp = new THREE.Vector3();
        const vecRight = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            controls.update();

            // æ›´æ–° Uniforms
            material.uniforms.iTime.value = time;
            material.uniforms.iCameraPos.value.copy(camera.position);

            // æ›´æ–°ç›¸æœºçŸ©é˜µç»™ Shader
            camera.getWorldDirection(vecForward);
            vecUp.copy(camera.up).applyQuaternion(camera.quaternion);
            vecRight.crossVectors(vecForward, vecUp).normalize();
            vecUp.crossVectors(vecRight, vecForward).normalize();

            material.uniforms.iCameraDir.value.copy(vecForward);
            material.uniforms.iCameraUp.value.copy(vecUp);
            material.uniforms.iCameraRight.value.copy(vecRight);
            material.uniforms.iFOV.value = Math.tan((camera.fov * Math.PI / 180) * 0.5);

            // HUD è®¡ç®—
            const currentDist = camera.position.length();
            const M = material.uniforms.uMass.value;
            const spin = material.uniforms.uSpin.value;
            const props = calcBlackHoleProperties(M, spin);
            
            updateHUD(currentDist, M, props);

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>